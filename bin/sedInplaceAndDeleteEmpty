#!/bin/bash

printUsage()
{
    cat <<HELPTEXT
Edit FILEs in place and remove the resulting FILE if it becomes completely empty.
HELPTEXT
    echo
    printf 'Usage: %q %s\n' "$(basename "$1")" 'SED-ARGUMENTS [...] [-i[SUFFIX]|--in-place[=SUFFIX]] [--] FILE [...] [-?|-h|--help]'
}

typeset -a sedInplaceArgs=(-i)
typeset -a sedArgs=()
typeset -a sedFiles=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printUsage "$0"; exit 0;;
	--in-place|--in-place=*|-i)
			sedInplaceArgs=("$1"); shift;;
	--)		sedArgs+=("$1"); shift; sedFiles=("$@"); break;;
	*)		sedArgs+=("$1"); shift;;
    esac
done
if [ ${#sedFiles[@]} -eq 0 ]; then
    # No files after -- captured yet; need to investigate parsed and
    # remaining args from behind for files.
    sedArgs+=("$@")
    while [ ${#sedArgs[@]} -ne 0 ]
    do
	lastArg="${sedArgs[-1]}"
	[ -e "$lastArg" ] || break

	sedFiles=("$lastArg" "${sedFiles[@]}")
	sedArgs=("${sedArgs[@]:0:${#sedArgs[@]}-1}")
    done
fi
if [ ${#sedFiles[@]} -eq 0 ]; then
    echo >&2 'ERROR: No FILE(s) passed.'
    echo >&2
    printUsage "$0" >&2
    exit 2
fi

sed "${sedInplaceArgs[@]}" "${sedArgs[@]}" "${sedFiles[@]}" || exit $?

status=0
for filespec in "${sedFiles[@]}"
do
    if [ -e "$filespec" -a ! -s "$filespec" ]; then
	rm --force -- "$filespec" || status=$?
    fi
done
exit $status
